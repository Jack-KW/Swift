My App implemented TextKit 2 layout mechanism soon after WWDC 2021, when Apple introduced it. The reason I adopt TextKit 2 is that it supports the high performance of long text scrolling, as the Apple team states: "TextKit 2 is extremely fast for an incredibly wide range of scenarios, from quickly rendering labels that are only a few lines each to laying out documents that are hundreds of megabytes being scrolled through at interactive rates. " But, back in 2021, Apple hadn't completed their migration to TextKit 2 yet, which means there was no TextKit 2 support on UITextView. 

Before WWDC 2022, my App worked fine based on the raw TextKit 2 components. When I say raw TextKit 2, I mean that we programmatically control the text layout process by NSTextLayoutManager, NSTextContentStorage, NSTextContainer, and a general UIScrollView with its controller. That solution was demonstrated in the **Meet TextKit 2** session of WWDC 2021. However, it couldn't benefit from the integrated Swift text components, such as highlighting text and the action menu functions on the UITextView. So, after about two years of waiting, I kicked off the transition from raw TextKit 2 to UITextView.

Compared with the raw TextKit 2 layout, rendering text on UITextView is much easier. However, free meals do not always taste great. The trade-off of implementing UITextView is that you must hand over the full text rendering control to this view. One very important rendering control for a reading App like mine is scrollRangeToVisible.

My solution without UITextView allows me to smoothly scroll the view to any location in huge documents, though the control is very complicated. However, the scrollRangeToVisible on iOS 16 was un-reliable. It not only scrolls to some wrong locations but can also scroll to some random places in a blank background. So, I had to spend a few weeks on experimenting with the mechanism behind scrollRangeToVisible and designing my App to cooperate with it to ensure a smooth user experience.

